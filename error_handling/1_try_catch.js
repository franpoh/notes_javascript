/* 
Table of Contents

> EXPLANATION
> THROW
>> Throw An Object
>> Rethrow An Exception
> THE EXCEPTION VARIABLE
> FINALLY
> EXAMPLES
>> Conditional Catch Blocks
>> Nested Try Blocks / Rethrows
*/



// ----------------------------- > EXPLANATION -----------------------------

// The try...catch statement is comprised of a try block and either a catch block, a finally block, or both. 
// The code in the try block is executed first, and if it throws an exception, the code in the catch block will be executed. 
// The code in the finally block will always be executed before control flow exits the entire construct

try {
    tryStatements
} catch (exceptionVar) {
    catchStatements
} finally {
    finallyStatements
}

// ----- tryStatements
// The statements to be executed.

// ----- catchStatements
// Statement that is executed if an exception is thrown in the try block.
// When a catch block is used, the catch block is executed when any exception is thrown from within the try block

// ----- exceptionVar (Optional)
// An optional identifier or pattern to hold the caught exception for the associated catch block.
// If the catch block does not use the exception's value, you can omit the exceptionVar and its surrounding parentheses.

// ----- finallyStatements
// Statements that are executed before control flow exits the 'try...catch...finally' construct.
// These statements execute regardless of whether an exception was thrown or caught.



// ----- Example

try {
    const num = Math.floor(Math.random() * 10) + 1; // Generate a number 1-10
    if (num >= 5) console.log(`The correct number is ${num}!`);
    else throw num;
} catch (exceptionVar) {
    console.log(`${exceptionVar} is wrong!`);
} finally {
    console.log('We have finally reached the end!');
}



// ----- Example try... catch in a function

function verifyNum(num) {
    try {
        if (num >= 5) console.log(`The correct number is ${num}!`);
        else throw num;
    } catch (e) {
        console.log(`${e} is wrong!`);
    }
}

a = verifyNum(2); // 2 is wrong!
b = verifyNum(9); // The correct number is 9!



// Unlike other constructs such as if or for, the try, catch, and finally blocks must be blocks, instead of single statements.

/* try doSomething(); */ // SyntaxError
/* catch (e) console.log(e); */



// ----------------------------- > THROW -----------------------------

// The throw statement throws a user-defined exception. 

// Execution of the current function will stop (the statements after throw won't be executed), 
// and control will be passed to the first catch block in the call stack. 

// If no catch block exists among caller functions, the program will terminate. 

function verifyNum(num) {
    if (num >= 5) console.log(`The correct number is ${num}!`);
    else throw new Error(`${num} is wrong!`);
}

try {
    const num = Math.floor(Math.random() * 10) + 1; // Generate a number 1-10
    verifyNum(num);
} catch (e) {
    console.error(e);
    // Expected output: Error: [num] is wrong!
}



// Use the throw statement to throw an exception. 
// When you throw an exception, expression specifies the value of the exception. 
// Each of the following throws an exception:

throw "Error2"; // generates an exception with a string value
throw 42; // generates an exception with the value 42
throw true; // generates an exception with the value true
throw new Error("Required"); // generates an error object with the message of Required

// Also note that the throw statement is affected by *automatic semicolon insertion (ASI) as no line terminator between the throw keyword and the expression is allowed. 
// * automatic semicolon insertion (ASI): JavaScript is able to automatically insert semicolons - ;



// ----------------------------- > THROW >> Throw An Object

// You can specify an object when you throw an exception. 
// You can then reference the object's properties in the catch block. 

// The following example creates an object of type UserException and uses it in a throw statement.

function NumException(message) {
    this.message = message;
    this.name = "NumException";
}

function verifyNum(num) {
    if (num >= 5) console.log(`The correct number is ${num}!`);
    else throw new NumException(`${num} is wrong! Error generated by:`)
}

try {
    const number = Math.floor(Math.random() * 10) + 1;
    verifyNum(number);
} catch (e) {
    console.error(e.message, e.name); // pass exception object to err handler
}



// ----------------------------- > THROW >> Rethrow An Exception

// You can use throw to rethrow an exception after you catch it. 

// The following example catches an exception with a numeric value and rethrows it if the value is over 50. 
// The rethrown exception propagates up to the enclosing function or to the top level so that the user sees it.

const number = Math.floor(Math.random() * 10) + 1; // Generate a number 1-10

function innerVerifyNum(num) {
    try {
        if (num >= 5) console.log(`The correct number is ${num}!`);
        else throw num;
    } catch (e) {
        console.log(`${e} is caught and rethrown in innerVerifyNum`); // and thus propogates up to its enclosing function, outerVerifyNum
        throw e;
    }
}

function outerVerifyNum(no) {
    try {
        innerVerifyNum(no);
    } catch (e) {
        console.log(`${e} is finally caught in outVerifyNum`);
    }
}

outerVerifyNum(number);



// ----------------------------- > THE EXCEPTION VARIABLE -----------------------------

// When an exception is thrown in the try block, exceptionVar (i.e., the e in catch (e)) holds the exception value. 
// You can use this variable to get information about the exception that was thrown. 
// This variable is only available in the catch block's scope.

// It need not be a single identifier. 
// You can use a destructuring pattern to assign multiple identifiers at once.

function MyError(msg) {
    this.name = 'MyError';
    this.message = msg;
}

try {
    throw new MyError('Herro this is error');
} catch ({ name, message }) {
    console.log(name); // MyError
    console.log(message); // Herro this is error
}



// The variables bound by the catch clause live in the same scope as the catch block, 
// so any variables declared in the catch block cannot have the same name as the variables bound by the catch clause. 

/* 
try {
  throw new MyError('Herro this is error');
} catch ({ name, message }) {
  let name; // SyntaxError: Identifier 'name' has already been declared
  let message; // SyntaxError: Identifier 'name' has already been declared
}
*/



// The exception variable is writable. 
// For example, you may want to normalize the exception value to make sure it's an Error object.

try {
    throw "Oops; this is not an Error object";
} catch (e) {
    if (!(e instanceof Error)) {
        e = new Error(e);
    }
    console.error(e.message);
}



// If you don't need the exception value, you can omit it along with the enclosing parentheses.

const nom = Math.floor(Math.random() * 10) + 1;

function verifyNum(num) {
    console.log(num);
    if (num >= 5) return;
    else throw new Error;
}


function isValidNum(num) {
    try {
        verifyNum(num);
        console.log('Valid');
    } catch {
        console.log('Invalid');
    }
}

isValidNum(nom);



// ----------------------------- > FINALLY -----------------------------

// The finally block contains statements to execute after the try block and catch block(s) execute, 
// but before the statements following the 'try...catch...finally' block. 



// Control flow will always enter the finally block, which can proceed in one of the following ways:

// Immediately before the try block finishes execution normally (and no exceptions were thrown);
// Immediately before the catch block finishes execution normally;
// NOTE: Immediately before a control-flow statement (return, throw, break, continue) is executed in the try block or catch block. 
// (See '----- Testing Control Flow Example')



// If an exception is thrown from the try block, even when there's no catch block to handle the exception, the finally block still executes, 
// in which case the exception is still thrown immediately after the finally block finishes executing.



// The following example shows one use case for the finally block. 
// The code opens a file and then executes statements that use the file; 
// the finally block makes sure the file always closes after it is used even if an exception was thrown.

openMyFile();

try {
    // tie up a resource
    writeMyFile(theData);
} finally {
    closeMyFile(); // always close the resource
}



// NOTE: Control flow statements (return, throw, break, continue) in the finally block will "mask" any completion value of the try block or catch block. 

// In this example, the try or catch block tries to return their return value,
// but before returning, the control flow is yielded to the finally block first, 
// so the finally block's return value is returned instead.


// ----- Testing Control Flow Example

function testingFlow() {
    try {
        console.log("testingFlow: try");
        const num = Math.floor(Math.random() * 10) + 1;
        if (num >= 5) return "try";
        else throw new Error;
    } catch {
        console.log("testingFlow: catch");
        return "catch";
    } finally {
        console.log("testingFlow: finally");
        return "finally";
    }
}

// as you can see, the 'testingFlow' console.logs shows that 'try', 'catch' (when applicable) and 'finally' runs as per normal
// but the only value that ever returns to the 'outside' console.log is 'finally'
// this is because, as mentioned above, the return statement in 'finally' will execute before the return statements in 'try' or 'catch'
console.log(`outside: ${testingFlow()}`);

// NOTE: It is generally a bad idea to have control flow statements in the finally block. Only use it for cleanup code.



// If the finally block returns a value, 
// this value becomes the return value of the entire try-catch-finally statement, 
// regardless of any return statements in the try and catch blocks. 

// This includes exceptions thrown inside of the catch block:

function finalValue () {
  try {
    try {
      throw new Error("oops");
    } catch (ex) {
      console.error("inner", ex.message);
      throw ex;
    } finally {
      console.log("finally");
      return;
    }
  } catch (ex) {
    console.error("outer", ex.message);
  }
};

finalValue();

// inner oops
// finally

// The outer "oops" is not thrown because of the return in the finally block. The same would apply to any value returned from the catch block.



// ----------------------------- > EXAMPLES -----------------------------

// ----------------------------- > EXAMPLES >> Conditional Catch Blocks

// You can create "Conditional catch blocks" by combining try...catch blocks with if...else if...else structures, like this:

try {
    myRoutine(); // may throw three types of exceptions
} catch (e) {
    if (e instanceof TypeError) {
        // statements to handle TypeError exceptions
    } else if (e instanceof RangeError) {
        // statements to handle RangeError exceptions
    } else if (e instanceof EvalError) {
        // statements to handle EvalError exceptions
    } else {
        // statements to handle any unspecified exceptions
        logMyErrors(e); // pass exception object to error handler
    }
}

// A common use case for this is to only catch (and silence) a small subset of expected errors, and then re-throw the error in other cases:

try {
    myRoutine();
} catch (e) {
    if (e instanceof RangeError) {
        // statements to handle this very common expected error
    } else {
        throw e; // re-throw the error unchanged
    }
}



// ----------------------------- > EXAMPLES >> Nested Try Blocks / Rethrows

try {
    try {
        throw new Error("oops");
    } finally {
        console.log("finally");
    }
} catch (ex) {
    console.error("outer", ex.message);
}

// finally
// outer oops



// Now, if we already caught the exception in the inner try block by adding a catch block:

try {
    try {
        throw new Error("oops");
    } catch (ex) {
        console.error("inner", ex.message);
    } finally {
        console.log("finally");
    }
} catch (ex) {
    console.error("outer", ex.message);
}

// inner oops
// finally



// And now, let's rethrow the error.

try {
    try {
        throw new Error("oops");
    } catch (ex) {
        console.error("inner", ex.message);
        throw ex;
    } finally {
        console.log("finally");
    }
} catch (ex) {
    console.error("outer", ex.message);
}

// inner oops
// finally
// outer oops



// Any given exception will be caught only once by the nearest enclosing catch block unless it is rethrown. 
// Of course, any new exceptions raised in the "inner" block (because the code in catch block may do something that throws), will be caught by the "outer" block.